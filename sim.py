import numpy as np
from robot import Octorotor
from planner import PolynomialTrajectory, WaypointGenerator
from control import PDTrajectoryControl
from viz import PlotState
import sys
import matplotlib
import matplotlib.pyplot as plt


class Sim:

    def __init__(self):
        # octorotor parameters
        mass = 10.
        Ixx = 1.
        Iyy = 1.
        Izz = 2.
        g = 9.81  # gravity
        rotor_thrust_coeff = 0.05  # rotor_thrust_N = rotor_thrust_coeff * rotor_rad_per_s ^ 2
        rotor_torque_coeff = 0.005  # rotor_torque_Nm = rotor_torque_coeff * rotor_rad_per_s ^ 2
        rotor_max_rad_per_s = 30  # maximum  allowed rotor spinning velocity (in both directions)
        rotor_min_rad_per_s = 0  # minimum rotor spinning velocity (stop)

        # PD gains for translational PD controller
        Kpos_p = 1.
        Kpos_d = 1.

        # PD gains for low-level attitude PD controller
        Kphi_p = 1.
        Kphi_d = 1.5

        Ktheta_p = 2.
        Ktheta_d = 3.

        Kpsi_p = 2.
        Kpsi_d = 3.

        # desired yaw for low-level attitude controller
        self.yaw_d = 0.

        self.PDPosition_gains = (Kpos_p, Kpos_d)
        self.PDAttitude_gains = (Kphi_p, Ktheta_p, Kpsi_p, Kphi_d, Ktheta_d, Kpsi_d)

        # linear drag force generated by the air resistance: linear velocities add to the force which slows octo
        A_x = A_y = A_z = 0.25

        self.octo_parameters = (mass, g, (Ixx, Iyy, Izz), (A_x, A_y, A_z))
        # initial state
        self.q_0 = [0., 0., 0., 0., 0., 0]  # octo state: [x, y, z, phi, theta, psi]^T
        self.qdot_0 = [0., 0., 0., 0., 0., 0.]


        # simulation parameters
        self.dt = 0.01

        # sim phases
        phase_count = 3
        self.phase_duration = [None] * phase_count
        self.p_f = [None] * phase_count  # desired final position
        self.phase_duration[0] = 5.
        self.p_f[0] = [0., 0., 1.]
        self.phase_duration[1] = 10.
        self.p_f[1] = [1., 1., 2.]
        self.phase_duration[2] = 15.
        self.p_f[2] = [2., 1., 2.5]

    def setSimPhases(self):
        # output: phases - array of simulation phases of the form:
        # n phases: (time_1, ... , time_n)
        sim_phases = np.zeros(len(self.phase_duration), dtype='object')
        sim_duration = 0.
        for i in range(len(self.phase_duration)):
            sim_phases[i] = (self.phase_duration[i], self.p_f[i])
            sim_duration += self.phase_duration[i]

        return sim_phases


def runSim():
    sim = Sim()
    sim_phases = sim.setSimPhases()
    octo = Octorotor(sim.octo_parameters)
    # PD position control to timed trajectory
    # init parameters: PDPosition_gains, octo_parameters
    octo.defineController(PDTrajectoryControl(sim.PDPosition_gains, sim.octo_parameters))
    octo.controller.initAttitudeController(sim.PDAttitude_gains, sim.yaw_d)  # low-level attitude controller

    # timed polynomial trajectory args: p0, pf, Tf)
    octo.definePlanner(PolynomialTrajectory())
    octo.initState(sim.q_0, sim.qdot_0)
    final_state = octo.updateState(sim_phases, sim.dt)
    [q, qdot] = np.split(final_state, 2, axis=1)

# plots ----------------------------------------------------------------------------------------------------------------
    time = np.arange(len(final_state)) * sim.dt
    viz = PlotState(q, time, three_dee=True)  # state inputs: q, qdot, time
    viz.plotPosition(sim.q_0[:3], sim_phases, sim.dt)
    viz.plotAttitude()
    plt.show()
